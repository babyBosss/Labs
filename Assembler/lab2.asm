row_n equ 40h ;строка 
col_n equ 41h ;столбец 
map_start equ 30h ;начало области хранения КС клавиатуры

org 0h 
ajmp start 
org 100h

start: 
mov a, #11110111b ;подготовка "бегущего нуля "  
mov r0, #map_start ;адрес начала карты состояние 

opros: 
mov p1, a ;"бегущий нуль" в порт 2 помещается 

setb p3.7 ; активация портов
setb p3.6 
setb p3.5 
setb p3.4 

mov b, p3 ;стартовое число из порта выходного помещается в B 
anl b, #0F0h ;фильтрация полученного числа от лишних бит
mov @r0, b ;записываем строку карты 
setb c ;подготовка нового опроса 
rrc a ; сдвиг "0" далее
inc r0 ;переход к следующей ячейке в карте 
cjne a, #11111111b, opros ;пока ноль не сдвинется 
mov r0, #map_start ;дешифрация карты


dc: 
mov a, @r0 ;читаем очередную строку карты 
cjne a, #0F0h, dck 
inc r0 ;если не нажата - просмотр карты далее 
cjne r0, #(map_start + 4), dc ;пока не будет конец карты, т.к. строки 4 
sjmp finish ;и переход в конец

dck: 
mov a, #(map_start + 4) ; в аккумулятор помещается т.к. в условии прописано, что первая строка - 4
clr c ;адрес последнего КС 
subb a, r0 ;вычитаем адрес с нажатой клавишей для номера строки 
mov row_n, a ;номер строки 
mov a, @r0 ;содержимое ячейки КС для 
mov col_n, #4;определения № столбца (col_n=4, т.к. первый столбец - 4 , по условию)

dloop1: 
rlc a ;последовательно идет сдвиг влево, т.к.значащие разряды - старшие
jnc finish ;пока не ноль вытиснится в перенос 
dec col_n 
mov r1, col_n 
cjne r1, #0, dloop1 

finish: 
sjmp $ ;конец программы 
end
